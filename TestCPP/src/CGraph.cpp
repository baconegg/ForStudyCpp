#include <iostream>

/*

 분석 해 보자!! 밑에는 설명 및 소스..

 방향성 그래프의 깊이 우선탐색 그래프 순회와, 그래프의 사이클 찾기

 당장 몇시간 뒤가 알고리즘 기말고사인데 ...
 
 그동안 선배들이 풀어왔던 기말고사 문제들을 쭉 훑어보니, DFS나 BFS 따위를 써서, 그래프를 순회시키거나 하는 문제들이 많이 보이더군요.

 그래서 심심해서 한번 구현해봤습니다. (사실 시험문제 중, DFS를 구현하고, cycle을 체크하라는 문제가 서너문제 출제되었더군요. -_-;)

 방향성 그래프인 경우, cycle을 출력시키도록 하고, 더이상 탐색이 불가능한(이어지지 않은) 경우엔, 그냥 탐색한 노드만 출력하는 간단한 코드입니다.


 원리는 뭐, 스택을 이용한 DFS 순회이고, 방문 노드의 인접한 노드들을, 가장 가까이 있는(알파벳 순으로) 순서대로 방문하도록 합니다.

 (스택이 없어도, 함수 call시 생성되는 함수들의 정보를 어차피 시스템 스택에 적재하니, 재귀는 보통 스택이 필요할때 자주 씁니다.)

 순회한 기록은 visit 전역배열에 차곡차곡 저장하다, 그래프를 순회하며, visit배열을 검사한 후, 만약 visit배열에 방문기록이 남아있을 경우, 사이클로 간주하고, 다른 인접노드를 탐색합니다.

 그러다가, 노드의 끝까지 방문하거나, 더이상 인접 노드가 없을 경우엔 알아서 함수들이 차곡차곡 return되겠죠.

 실행결과는 다음과 같습니다.

 A
 C
 E
 cycle (E~C)
 F


 */

/*int graph[6][6] =
{
{ 0, 0, 1, 0, 0, 0 },
{ 0, 0, 1, 0, 0, 1 },
{ 0, 0, 0, 0, 1, 0 },
{ 1, 0, 0, 0, 1, 0 },
{ 0, 0, 1, 0, 0, 1 },
{ 0, 0, 0, 0, 0, 0 } };*/

int graph[10][10] =
{
{ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0 },
{ 1, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
{ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
{ 1, 0, 0, 0, 0, 1, 1, 0, 0, 0 },
{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0 },
{ 0, 1, 1, 1, 0, 0, 0, 1, 1, 1 },
{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 1 },
{ 0, 0, 0, 0, 1, 1, 0, 0, 1, 0 },
{ 0, 0, 0, 0, 0, 1, 0, 1, 0, 1 },
{ 0, 0, 0, 0, 0, 1, 1, 0, 1, 0 }};

int size = 10;
bool visit[10];

void dfs(int node)
{
	if (!visit[node]){    // 방문하지 않은 노드만 출력
		/*std::cout << "방문하지 않은 노드 " << node << std::endl;*/
		std::cout << static_cast<char>(node + 'A') << std::endl;
	}
	visit[node] = true; // 방문!

	if (node < size)
	{
		for (int i = 0; i < size; i++)
		{
			if (graph[node][i] == 1)
			{
				if (visit[i])
				{
					/*std::cout << "방문한 노드 " << "graph[" << node << "]" << "["  << i << "]" << std::endl;*/
					// 이미 방문한 노드이므로, 사이클이 형성되었음.
					std::cout << "cycle (" << static_cast<char>(node + 'A')
							<< "~" << static_cast<char>(i + 'A') << ")"
							<< std::endl;
					continue;   // 사이클이 형성되므로, i는 이미 호출된 노드, 다른 인접노드를 탐색한다.
				}

				dfs(i);
			}
		}
	}
}

int main(int argc, char* argv[])
{
	dfs(0);

	return 0;
}
